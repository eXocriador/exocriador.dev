import React, { useState, useRef, useEffect } from "react";
import { useInView } from "react-intersection-observer";
import {
  generateImageUrls,
  generateBlurPlaceholderUrl
} from "../../utils/imageOptimization";
import styles from "./OptimizedImage.module.css";

interface OptimizedImageProps {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  className?: string;
  priority?: boolean; // –î–ª—è –≤–∞–∂–ª–∏–≤–∏—Ö –∑–æ–±—Ä–∞–∂–µ–Ω—å (above the fold)
  placeholder?: string; // –ö–∞—Å—Ç–æ–º–Ω–∏–π placeholder
  onLoad?: () => void;
  onError?: () => void;
}

const OptimizedImage: React.FC<OptimizedImageProps> = ({
  src,
  alt,
  width,
  height,
  className = "",
  priority = false,
  placeholder,
  onLoad,
  onError
}) => {
  const [isLoaded, setIsLoaded] = useState(false);
  const [hasError, setHasError] = useState(false);
  const [imageSrc, setImageSrc] = useState<string>("");

  const imgRef = useRef<HTMLImageElement>(null);

  // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ Intersection Observer –¥–ª—è lazy loading
  const { ref: inViewRef, inView } = useInView({
    triggerOnce: true,
    threshold: 0.1,
    rootMargin: "50px" // –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –∑–∞ 50px –¥–æ –ø–æ—è–≤–∏
  });

  // –ì–µ–Ω–µ—Ä—É—î–º–æ –æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω—ñ URL –¥–ª—è –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
  const imageUrls = generateImageUrls(src);

  useEffect(() => {
    if (inView && !imageSrc) {
      if (priority) {
        // –î–ª—è –≤–∞–∂–ª–∏–≤–∏—Ö –∑–æ–±—Ä–∞–∂–µ–Ω—å –∑–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –æ–¥—Ä–∞–∑—É
        setImageSrc(src);
      } else {
        // –î–ª—è —ñ–Ω—à–∏—Ö - —Ç—ñ–ª—å–∫–∏ –∫–æ–ª–∏ –≤–æ–Ω–∏ –≤ –∑–æ–Ω—ñ –≤–∏–¥–∏–º–æ—Å—Ç—ñ
        setImageSrc(src);
      }
    }
  }, [inView, src, imageSrc, priority]);

  const handleImageLoad = () => {
    setIsLoaded(true);
    onLoad?.();
  };

  const handleImageError = () => {
    setHasError(true);
    onError?.();
  };

  // –û–±'—î–¥–Ω—É—î–º–æ refs
  const setRefs = (element: HTMLDivElement | null) => {
    inViewRef(element);
    if (imgRef.current) {
      imgRef.current = element?.querySelector("img") || null;
    }
  };

  const blurPlaceholder = placeholder || imageUrls.placeholder;

  return (
    <div
      ref={setRefs}
      className={`${styles.imageContainer} ${className}`}
      style={{ width, height }}
    >
      {/* Blur placeholder */}
      {!isLoaded && !hasError && (
        <div className={styles.placeholderContainer}>
          <img
            src={blurPlaceholder}
            alt=""
            className={styles.blurPlaceholder}
            aria-hidden="true"
          />
          <div className={styles.loadingSpinner}>
            <div className={styles.spinner}></div>
          </div>
        </div>
      )}

      {/* –û—Å–Ω–æ–≤–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è */}
      {imageSrc && (
        <picture>
          {/* WebP —Ñ–æ—Ä–º–∞—Ç –¥–ª—è –±—Ä–∞—É–∑–µ—Ä—ñ–≤, —â–æ –ø—ñ–¥—Ç—Ä–∏–º—É—é—Ç—å */}
          <source srcSet={imageUrls.formats.webp} type="image/webp" />
          {/* AVIF —Ñ–æ—Ä–º–∞—Ç –¥–ª—è –±—Ä–∞—É–∑–µ—Ä—ñ–≤, —â–æ –ø—ñ–¥—Ç—Ä–∏–º—É—é—Ç—å */}
          <source srcSet={imageUrls.formats.avif} type="image/avif" />
          {/* Fallback JPEG */}
          <img
            ref={imgRef}
            src={imageUrls.formats.jpg}
            alt={alt}
            className={`${styles.optimizedImage} ${
              isLoaded ? styles.loaded : ""
            }`}
            loading={priority ? "eager" : "lazy"}
            srcSet={imageUrls.srcSet}
            sizes={imageUrls.sizes}
            onLoad={handleImageLoad}
            onError={handleImageError}
            style={{ width, height }}
          />
        </picture>
      )}

      {/* Error state */}
      {hasError && (
        <div className={styles.errorContainer}>
          <div className={styles.errorIcon}>üì∑</div>
          <p className={styles.errorText}>–ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è –Ω–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏–ª–æ—Å—è</p>
        </div>
      )}
    </div>
  );
};

export default OptimizedImage;
